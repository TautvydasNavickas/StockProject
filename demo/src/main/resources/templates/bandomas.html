<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>How to Create Custom Candlestick Chart In Chart JS Part 31</title>
  <style>
      * {
        margin: 0;
        padding: 0;
        font-family: sans-serif;
      }
      .chartMenu {
        width: 100vw;
        height: 40px;
        background: #1A1A1A;
        color: rgba(255, 26, 104, 1);
      }
      .chartMenu p {
        padding: 10px;
        font-size: 20px;
      }
      .chartCard {
        width: 100vw;
        height: calc(100vh - 40px);
        background: rgba(255, 26, 104, 0.2);
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .chartBox {
        width: 80%;
        padding: 20px;
        border-radius: 20px;
        border: solid 3px rgba(255, 26, 104, 1);
        background: white;
      }
    </style>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css" integrity="sha512-5A8nwdMOWrSz20fDsjczgUidUBR8liPYU+WymTZP1lmY9G6Oc7HlZv156XqnsgNUzTyMefFTcsFH/tnJE/+xBg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
</head>
<body>
<div class="chartMenu">
</div>
<div class="chartCard">
  <div class="chartBox">
    <canvas id="myChart"></canvas>
    <input onclick="update('ma')" type="checkbox" id="ma"> Moving Average <br>
    <input onclick="update('bb')" type="checkbox" id="bb"> Boilinger Band <br>
    <input onclick="update('rsi')" type="checkbox" id="rsi"> Relative Strength Index <br>
    <button onclick="reset()">Reset</button>
  </div>
</div>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

<script>
    Chart.defaults.font.family = "'Helvetica', 'Helvetica Neue', 'Arial', sans-serif, 'FontAwesome'"; 
    // setup 
    const data = {
      //labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
      datasets: [{
        label: 'Weekly Sales',
        data: [
          {
            x: new Date('2022-06-01').setHours(0, 0, 0, 0),
            o: 1.25,
            h: 1.35,
            l: 1.00,
            c: 1.10,
            s: [1.25, 1.10]
          },
          {
            x: new Date('2022-06-02').setHours(0, 0, 0, 0),
            o: 1.10,
            h: 1.35,
            l: 1.00,
            c: 1.20,
            s: [1.10, 1.20]
          },
          {
            x: new Date('2022-06-03').setHours(0, 0, 0, 0),
            o: 1.20,
            h: 1.50,
            l: 1.20,
            c: 1.50,
            s: [1.20, 1.50]
          },
          {
            x: new Date('2022-06-04').setHours(0, 0, 0, 0),
            o: 1.50,
            h: 1.80,
            l: 1.20,
            c: 1.40,
            s: [1.50, 1.40]
          },
          {
            x: new Date('2022-06-05').setHours(0, 0, 0, 0),
            o: 1.40,
            h: 2.00,
            l: 1.30,
            c: 1.75,
            s: [1.40, 1.75]
          },
          {
            x: new Date('2022-06-08').setHours(0, 0, 0, 0),
            o: 1.75,
            h: 2.50,
            l: 1.30,
            c: 1.85,
            s: [1.75, 1.85]
          },
          {
            x: new Date('2022-06-09').setHours(0, 0, 0, 0),
            o: 1.85,
            h: 2.50,
            l: 1.30,
            c: 1.99,
            s: [1.85, 1.99]
          },
          {
            x: new Date('2022-06-10').setHours(0, 0, 0, 0),
            o: 1.99,
            h: 2.25,
            l: 1.80,
            c: 2.05,
            s: [1.99, 2.05]
          }
        ],
        movingAverage: [1.20, 1.30, 1.40, 1.50, 1.45, 1.55, 1.30, 1.40],
        boilingerBand: {
          bottom: [0.20, 0.30, 0.40, 0.50, 0.45, 0.55, 0.30, 0.40],
          top: [2.20, 2.30, 2.40, 2.50, 2.45, 2.55, 2.30, 2.40]
        },
        backgroundColor: (ctx) => {
          const { raw: { o, c} } = ctx;
          let color;
          if(c >= o) {
            color = 'rgba(75, 192, 192, 1)';
          } else {
            color = 'rgba(255, 26, 104, 1)';
          }
          return color;
        },
        borderColor: 'rgba(0, 0, 0, 1)',
        borderWidth: 2,
        borderSkipped: false,
        yAxisID: 'y'
      }, { // RSI
        type: 'line',
        label: 'RSI Indicator',
        //backgroundColor: 'black',
        borderColor: 'black',
        data: [
          { x: new Date('2022-06-01').setHours(0, 0, 0, 0), s: 20 },
          { x: new Date('2022-06-02').setHours(0, 0, 0, 0), s: 25 },
          { x: new Date('2022-06-03').setHours(0, 0, 0, 0), s: 30 },
          { x: new Date('2022-06-04').setHours(0, 0, 0, 0), s: 40 },
          { x: new Date('2022-06-05').setHours(0, 0, 0, 0), s: 60 },
          { x: new Date('2022-06-08').setHours(0, 0, 0, 0), s: 80 },
          { x: new Date('2022-06-09').setHours(0, 0, 0, 0), s: 60 },
          { x: new Date('2022-06-10').setHours(0, 0, 0, 0), s: 20 },
        ],
        yAxisID: 'yLower',
        hitRadius: 0,
        pointRadius: 0,
      }, { // MACD
        type: 'bar',
        label: 'MACD Indicator',
        backgroundColor: (ctx) => {
          const { raw: { s} } = ctx;
          let color;
          if(s[0] < s[1]) {
            color = 'rgba(75, 192, 192, 1)';
          } else {
            color = 'rgba(255, 26, 104, 1)';
          }
          return color;
        },
        //borderColor: 'black',
        data: [
          { x: new Date('2022-06-01').setHours(0, 0, 0, 0), s: [0, 1] },
          { x: new Date('2022-06-02').setHours(0, 0, 0, 0), s: [0, 2] },
          { x: new Date('2022-06-03').setHours(0, 0, 0, 0), s: [0, 3] },
          { x: new Date('2022-06-04').setHours(0, 0, 0, 0), s: [0, 2] },
          { x: new Date('2022-06-05').setHours(0, 0, 0, 0), s: [0, 1] },
          { x: new Date('2022-06-08').setHours(0, 0, 0, 0), s: [0, -1] },
          { x: new Date('2022-06-09').setHours(0, 0, 0, 0), s: [0, -2] },
          { x: new Date('2022-06-10').setHours(0, 0, 0, 0), s: [0, -1] },
        ],
        //yAxisID: 'yLower',
        hitRadius: 0,
        pointRadius: 0,
      }]
    };

    // candlestick plugin block
    const candlestick = {
      id: 'candlestick',
      beforeDatasetsDraw(chart, args, pluginOptions) {
        const { ctx, data, chartArea: { top, bottom, left, right, width, height }, scales: {x, y} } = chart;

        ctx.save();
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(0, 0, 0, 1)';

        //console.log(chart.getDatasetMeta(0).data[0])

        data.datasets[0].data.forEach((datapoint, index) => {
          ctx.beginPath();
          ctx.moveTo(chart.getDatasetMeta(0).data[index].x, chart.getDatasetMeta(0).data[index].y);
          ctx.lineTo(chart.getDatasetMeta(0).data[index].x, y.getPixelForValue(data.datasets[0].data[index].h));
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(chart.getDatasetMeta(0).data[index].x, chart.getDatasetMeta(0).data[index].y);
          ctx.lineTo(chart.getDatasetMeta(0).data[index].x, y.getPixelForValue(data.datasets[0].data[index].l));
          ctx.stroke();
        })
      }
    }

    // const movingAverage = {
    //   id: 'movingAverage',
    //   afterDatasetsDraw(chart, args, pluginOptions) {
    //     const { ctx, data, scales: {x, y} } = chart;

    //     console.log(data.datasets[0].movingAverage);

    //     ctx.save();

    //     const closingPrice = data.datasets[0].data.map(datapoint => {
    //       return datapoint.c;
    //     });

    //     const average = 4;
    //     const movingAverage = [];


        // for (let i = 0; i < closingPrice.length; i++) {
        //   const mean = (closingPrice[i - 2] + closingPrice[i - 1] + closingPrice[i]) / average;
        //   movingAverage.push(mean);
        // };

        // for (let i = 0; i < closingPrice.length; i++) {
        //   const mean = closingPrice.slice(i, average + i);

        //   if(mean.length === average) {
        //     const sumTotal = mean.reduce((total, value) => { return total + value});
        //     console.log(sumTotal)
        //     movingAverage.push(sumTotal / average)
        //   }

        // }

        // console.log(movingAverage)

        // for(let i = 0; i < closingPrice.length; i++) {
        //   const mean = closingPrice.slice(i - average, i);
        //   if(mean.length === average) {
        //     const totalSum = mean.reduce((total, value) => { return total + value });
        //     movingAverage.push(totalSum / average);
        //   } else {
        //     movingAverage.push(undefined)
        //   }
        // }

        //console.log(movingAverage)


    //     ctx.beginPath();
    //     ctx.strokeStyle = 'rgba(102, 102, 102, 1)';
    //     ctx.moveTo(chart.getDatasetMeta(0).data[0].x, y.getPixelForValue(movingAverage[0]));
    //     for (let i = 1; i < data.datasets[0].data.length; i++){
    //       ctx.lineTo(chart.getDatasetMeta(0).data[i].x, y.getPixelForValue(movingAverage[i]));
    //     }

    //     ctx.stroke();
    //   }
    // }

    // customScale plugin block
    const customScale = {
      id: 'customScale',
      afterDatasetsDraw(chart, args, pluginOptions) {
        const { ctx, data, chartArea: { top, bottom, left, right, width, height }, scales: {x, y} } = chart;

        ctx.save();

        const dataOptions = {
          day: 'numeric',
          month: 'short'
        };

        data.datasets[0].data.forEach((datapoint, index) => {
          ctx.textAlign = 'center';
          ctx.font = 'bold 12px sans-serif';
          ctx.fillStyle = 'rgba(102, 102, 102, 1)';
          ctx.fillText(new Date(datapoint.x).toLocaleString('en', dataOptions), x.getPixelForValue(datapoint.x), bottom + 20);
        })
      }
    }

    // crosshair plugin block
    const crosshair = {
      id: 'crosshair',
      afterDatasetsDraw(chart, args, pluginOptions) {
        const { ctx, data, tooltip, chartArea: {top, bottom, left, right, width, height}, scales: {x, y} } = chart
        if(tooltip._active && tooltip._active.length) {
          ;
          const activePoint = tooltip._active[0];
          ctx.setLineDash([3, 3]);
          ctx.lineWidth = 2;
          ctx.strokeStyle = 'rgba(102, 102, 102, 1)';

          lines(activePoint.element.x, top, activePoint.element.x, bottom);
          lines(left, y.getPixelForValue(tooltip.dataPoints[0].raw.c), right, y.getPixelForValue(tooltip.dataPoints[0].raw.c));
          function lines(startX, startY, endX, endY) {
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            ctx.closePath();
          }
          ctx.setLineDash([]);

          // crosshairlabel left
          ctx.beginPath();
          ctx.fillRect(0, y.getPixelForValue(tooltip.dataPoints[0].raw.c) - 12, left, 24)

          // crosshairlabel bottom
          ctx.beginPath();
          console.log(tooltip)
          const textWidth = ctx.measureText(tooltip.dataPoints[0].label).width + 10;
          ctx.fillRect(x.getPixelForValue(tooltip.dataPoints[0].raw.x) - (textWidth / 2), top + height, textWidth, 24);

          ctx.fillStyle = 'white';
          ctx.font = 'bold 12px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('$ '+tooltip.dataPoints[0].raw.c.toFixed(2), left / 2, y.getPixelForValue(tooltip.dataPoints[0].raw.c));

          ctx.fillText(tooltip.dataPoints[0].label, x.getPixelForValue(tooltip.dataPoints[0].raw.x), top + height + 12);

          chart.canvas.style.cursor = 'crosshair';
        } else {
          chart.canvas.style.cursor = 'default';
        }
      }
    }

    // indicators plugin block
    const indicators = {
      id: 'indicators',
      afterDatasetsDraw(chart, args, pluginOptions) {
        const { ctx, data, scales: {x, y} } = chart;

        ctx.save();
        const ma = document.getElementById('ma');

        const darray = data.datasets[0].data.map(date => {
          return date.x;
        });
        const dateIndex = darray.indexOf(x.min)



        if(ma.checked === true) {
          // Moving Average
          ctx.beginPath();
          ctx.strokeStyle = 'rgba(102, 102, 102, 1)';
          ctx.lineWidth = 2;

          ctx.moveTo(chart.getDatasetMeta(0).data[dateIndex].x, y.getPixelForValue(data.datasets[0].movingAverage[0]));
          for (let i = dateIndex + 1; i < data.datasets[0].data.length; i++){
            ctx.lineTo(chart.getDatasetMeta(0).data[i].x, y.getPixelForValue(data.datasets[0].movingAverage[i]));
          }
          ctx.stroke();
          ctx.closePath();
          ctx.restore();
        }
      },
      beforeDatasetsDraw(chart, args, pluginOptions) {
        const { ctx, chartArea: {top, bottom, left, right}, data, scales: {x, y, yLower} } = chart;

        ctx.save();

        const darray = data.datasets[0].data.map(date => {
          return date.x;
        });
        const dateIndex = darray.indexOf(x.min)

        const bb = document.getElementById('bb');

        if(bb.checked === true) {
          const boilingerBandLength = data.datasets[0].boilingerBand.bottom.length - 1;

          ctx.beginPath();
          ctx.fillStyle = 'rgba(255, 159, 64, 0.2)';
          ctx.strokeStyle = 'rgba(255, 159, 64, 1)';
          ctx.moveTo(chart.getDatasetMeta(0).data[dateIndex].x, y.getPixelForValue(data.datasets[0].boilingerBand.bottom[dateIndex]));

          for (let i = dateIndex + 1; i <= boilingerBandLength; i++) {
            ctx.lineTo(
              chart.getDatasetMeta(0).data[i].x, y.getPixelForValue(data.datasets[0].boilingerBand.bottom[i])
            )
          };

          for (let j = boilingerBandLength; dateIndex <= j; j--) {
            ctx.lineTo(
              chart.getDatasetMeta(0).data[j].x, y.getPixelForValue(data.datasets[0].boilingerBand.top[j])
            )
          }

          ctx.closePath();
          ctx.stroke();
          ctx.fill();
          ctx.restore();
        }

        // RSI Indicator
        RSIlines(left, yLower.getPixelForValue(70), right, yLower.getPixelForValue(70), 'rgba(255, 26, 104, 1)');
        RSIlines(left, yLower.getPixelForValue(30), right, yLower.getPixelForValue(30), 'rgba(75, 192, 192, 1)');

        function RSIlines(xStart, yStart, xEnd, yEnd, color) {
          ctx.beginPath();
          ctx.strokeStyle = color;
          ctx.lineWidth = 1;
          ctx.moveTo(xStart, yStart);
          ctx.lineTo(xEnd, yEnd);
          ctx.stroke();
          ctx.restore();
        };
      }
    }

    // config 
    const config = {
      type: 'bar',
      data,
      options: {
        layout: {
          padding: {
            bottom: 20,
            left: 10
          }
        },
        parsing: {
          xAxisKey: 'x',
          yAxisKey: 's',
          yLowerAxisKey: 'x',
        },
        scales: {
          x: {
            stacked: true,
            min: (ctx) => {
              //console.log(ctx.chart.data.datasets[0].data[0].x)
              return ctx.chart.data.datasets[0].data[0].x;
            },
            max: (ctx) => {
              //console.log(ctx.chart.data.datasets[0].data[0].x)
              const maxLength = ctx.chart.data.datasets[0].data.length - 1;
              return ctx.chart.data.datasets[0].data[maxLength].x;
            },
            offset: false,
            type: 'timeseries',
            time: {
              unit: 'day',
              tooltipFormat: 'MMM d, yyyy'
            },
            grid: {
              display: false,
            },
            ticks: {
              display: false,
            }
          },
          yMacd: {
            beginAtZero: true,
            type: 'linear',
            stack: 'yScale',
            stackWeight: 1,
            ticks: {
              count: 3,
              //display: false
            }
          },
          yLower: {
            beginAtZero: true,
            max: 100,
            type: 'linear',
            stack: 'yScale',
            stackWeight: 0,
            ticks: {
              count: 3,
              display: false
            }
          },
          y: {
            beginAtZero: true,
            grace: 1,
            stack: 'yScale',
            stackWeight: 4,
          }
        },
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            callbacks: {
              afterTitle: (ctx) => {
                if(ctx[0].raw.o <= ctx[0].raw.c) {
                  return '\uf062 CHRT.JS'
                } else {
                  return '\uf063 CHRT.JS'
                }
                // return '\uf063 X CHRT.JS'
                // f063 arrow down
                //f062 arrow up
              },
              beforeBody: (ctx) => {
              //  console.log(ctx)
                const bodyArray = [
                  `O: ${ctx[0].raw.o.toFixed(2)}`,
                  `H: ${ctx[0].raw.h.toFixed(2)}`,
                  `L: ${ctx[0].raw.l.toFixed(2)}`,
                  `C: ${ctx[0].raw.c.toFixed(2)}`,
                ];
                return bodyArray
              },
              label: (ctx) => {
                return '';
              }
            }
          }
        }
      },
      plugins: [indicators, candlestick, customScale, crosshair]
    };

    // render init block
    const myChart = new Chart(
      document.getElementById('myChart'),
      config
    );

    myChart.canvas.addEventListener('mousedown', (e) => {
      dragStart(myChart, e);
    });

    // check later if needed ??
    window.addEventListener('mouseup', (e) => {
      myChart.canvas.onmousemove = null;
    });

    function dragStart(chart, drag) {
      //console.log(drag.offsetX)
      const { ctx, canvas, data, chartArea: {top, bottom, left, right, width, height}, scales: {x,y} } = chart;

      if(drag.offsetX >= left && drag.offsetX <= right) {
        canvas.onmousemove = (e) => {
          dragMove(e);
        }

        function dragMove(dragDelta) {
          chart.update('none');
          //console.log(dragDelta.offsetX);
          const datesArray = data.datasets[0].data.map((date, index) => {
            return date.x;
          })

          const timestampBegin = x.getValueForPixel(drag.offsetX);
          const dayTimestampBegin = new Date(timestampBegin).setHours(0, 0, 0, 0);
          const startDragPoint = datesArray.indexOf(dayTimestampBegin);

          const timestampEnd = x.getValueForPixel(dragDelta.offsetX);
          const dayTimestampEnd = new Date(timestampEnd).setHours(0, 0, 0, 0);
          let endDragPoint = datesArray.indexOf(dayTimestampEnd);
          let zoomBox = dragDelta.offsetX - drag.offsetX;

          //console.log(zoomBox)
          if(dragDelta.offsetX <= left) {
            zoomBox = left - drag.offsetX;
          }

          if(endDragPoint === -1) {
            const temp = datesArray.map(date => Math.abs(new Date() - new Date(date).getTime()));
            const closesIndex = temp.indexOf(Math.min(...temp));
            endDragPoint = datesArray.indexOf(datesArray[closesIndex])
          }

          ctx.save();
          ctx.strokeStyle = 'rgba(54, 162, 235, 1)';
          ctx.fillStyle = 'rgba(54, 162, 235, 0.2)';
          ctx.fillRect(drag.offsetX, top, zoomBox, height);
          ctx.strokeRect(drag.offsetX, top, zoomBox, height);

          canvas.onmouseup = (e) => {
            dragEnd(e, startDragPoint, endDragPoint)
          }

          window.onmouseup = (e) => {
            dragEnd2()
          }

          function dragEnd2(){
            chart.update('none');
          }

          function dragEnd(dragEnd, start, end) {
            console.log(start)
            console.log(end)

            if(start <= end) {
              chart.config.options.scales.x.min = datesArray[start];
              chart.config.options.scales.x.max = datesArray[end];
            } else {
              chart.config.options.scales.x.min = datesArray[end];
              chart.config.options.scales.x.max = datesArray[start];
            }

            chart.update();
          }
        }
      }
    }

    function reset() {
      const length = myChart.data.datasets[0].data.length - 1;
      myChart.config.options.scales.x.min = myChart.data.datasets[0].data[0].x;
      myChart.config.options.scales.x.max = myChart.data.datasets[0].data[length].x;
      myChart.config.options.scales.yLower.stackWeight = 0;
      myChart.config.options.scales.yLower.ticks.display = false;

      document.getElementById('ma').checked = false;
      document.getElementById('bb').checked = false;
      document.getElementById('rsi').checked = false;
      myChart.update();
    }

    function update(indicator) {
      if(document.getElementById('rsi').checked === true) {
        myChart.config.options.scales.yLower.stackWeight = 1;
        myChart.config.options.scales.yLower.ticks.display = true;
      } else {
        myChart.config.options.scales.yLower.stackWeight = 0;
        myChart.config.options.scales.yLower.ticks.display = false;
      }
      myChart.update();
    }
    </script>

</body>
</html>
